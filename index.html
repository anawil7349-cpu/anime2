<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giant Heart Particles - Vibrant Neon (Optimized Glow)</title>
    <link href="https://fonts.googleapis.com/css2?family=Itim&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #8efbff; /* พื้นหลังดำสนิท (แก้เป็นม่วงตามที่คุณตั้งไว้) */
        }
        canvas {
            display: block;
        }
        #fontLoader {
            font-family: 'Itim', cursive; 
            position: absolute;
            color: transparent;
            z-index: -1;
        }
    </style>
</head>
<body>

    <div id="fontLoader">ม</div>
    <canvas id="heartCanvas"></canvas>

    <script>
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        let w = canvas.width = window.innerWidth;
        let h = canvas.height = window.innerHeight;
        let baseScale = Math.min(w, h) / 50; 

        function getTextPoints(text) {
            const tempCanvas = document.createElement('canvas');
            const tCtx = tempCanvas.getContext('2d');
            tempCanvas.width = w;
            tempCanvas.height = h;
            
            const fontSize = Math.min(w, h) / 1.8; 
            
            tCtx.font = `400 ${fontSize}px "Itim", cursive`; 
            tCtx.fillStyle = 'white';
            tCtx.textAlign = 'center';
            tCtx.textBaseline = 'middle';
            
            const moveX = 0; 
            const moveY = baseScale * 2; 

            tCtx.fillText(text, (w / 2) + moveX, (h / 2) + moveY);
            
            const imageData = tCtx.getImageData(0, 0, w, h).data;
            const points = [];
            const step = 3; 
            
            for (let y = 0; y < h; y += step) {
                for (let x = 0; x < w; x += step) {
                    const index = (y * w + x) * 4;
                    const alpha = imageData[index + 3]; 
                    if (alpha > 128) { 
                        points.push({ x, y });
                    }
                }
            }
            return points;
        }

        function getHeartPoint(t) {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
            return { x, y };
        }

        let pPoints = [];
        const particles = [];
        const backgroundStars = [];
        let time = 0;

        class Star {
            constructor() {
                this.x = Math.random() * w;
                this.y = Math.random() * h;
                this.size = Math.random() * 1.5 + 0.5;
                this.blinkPhase = Math.random() * Math.PI * 2; 
                this.blinkSpeed = Math.random() * 0.01 + 0.003; 
                this.vy = -(Math.random() * 0.1 + 0.03); 
                
                const colors = ['#FFFFFF', '#FFFF00', '#00FFFF', '#2bff00', '#8800ff'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                this.blinkPhase += this.blinkSpeed;
                this.alpha = Math.abs(Math.sin(this.blinkPhase)) * 0.8 + 0.2;
                this.y += this.vy;
                if (this.y < 0) {
                    this.y = h;
                    this.x = Math.random() * w;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha * 0.5})`; 
                ctx.fill();
            }
        }

        class Particle {
            constructor(type, targetIndex, isCore) {
                this.type = type; 
                this.targetIndex = targetIndex;
                this.isCore = isCore;
                
                if (this.type === 'text') {
                     // แก้สีจาก #FFFF ให้เป็น #FFFFFF เพื่อป้องกันบั๊กสีเพี้ยน
                     const vibrantTextColors = ['#FFFFFF', '#a125ff', '#a125ff', '#57f9ff', '#8efbff'];
                     this.color = vibrantTextColors[Math.floor(Math.random() * vibrantTextColors.length)];
                } 
                else {
                     const intenseHeartColors = ['#FF0000', '#FF0000', '#FF0000', '#FF0000', '#FF0000', '#FF009c'];
                     this.color = intenseHeartColors[Math.floor(Math.random() * intenseHeartColors.length)];
                }

                this.spreadX = 0;
                this.spreadY = 0;
                if (this.type === 'heart') {
                    let spreadAmount = this.isCore ? baseScale * 1.0 : baseScale * 6.0;
                    const spreadAngle = Math.random() * Math.PI * 2;
                    const spreadRadius = Math.random() * spreadAmount;
                    this.spreadX = Math.cos(spreadAngle) * spreadRadius;
                    this.spreadY = Math.sin(spreadAngle) * spreadRadius;
                }

                const angle = Math.random() * Math.PI * 2;
                const dist = Math.max(w, h) * (0.5 + Math.random() * 0.5);
                this.x = w / 2 + Math.cos(angle) * dist;
                this.y = h / 2 + Math.sin(angle) * dist;
                
                this.speed = (Math.random() * 0.001 + 0.005); 
                this.maxSpeed = isCore ? (Math.random() * 0.08 + 0.001) : (Math.random() * 0.008 + 0.004);
                
                this.t = Math.random() * Math.PI * 2;
                this.size = this.type === 'heart' ? (Math.random() * 2.5 + 1.0) : (Math.random() * 2 + 1);
                
                this.life = 0;
                this.maxLife = 40 + Math.random() * 200; 
            }

            resetFlow() {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.max(w, h) * 0.7;
                this.x = w / 2 + Math.cos(angle) * distance;
                this.y = h / 2 + Math.sin(angle) * distance;
                this.speed = Math.random() * 0.006 + 0.003; 
                this.life = 0;
            }

            update(beatValue) {
                if (this.speed < this.maxSpeed) {
                    this.speed += 0.0001; 
                }

                let targetX, targetY;
                if (this.type === 'heart') {
                    if (this.isCore) this.t += 0.0015; 
                    const pos = getHeartPoint(this.t);
                    const heartShapeScale = (baseScale * 1.2) + beatValue * 1.2; 
                    targetX = w / 2 + pos.x * heartShapeScale + this.spreadX;
                    targetY = h / 2 + pos.y * heartShapeScale + this.spreadY;
                } else {
                    const pPoint = pPoints[this.targetIndex];
                    if(!pPoint) return; 
                    const textScale = 1 + (beatValue * 0.03); 
                    targetX = w / 2 + (pPoint.x - w / 2) * textScale;
                    targetY = h / 2 + (pPoint.y - h / 2) * textScale;
                }

                this.x += (targetX - this.x) * this.speed;
                this.y += (targetY - this.y) * this.speed;

                if (!this.isCore) {
                    this.life++;
                    if (this.life > this.maxLife) this.resetFlow();
                }
            }

            draw() {
                // เทคนิค Fake Glow ทำงานเบากว่า แต่ฟุ้งเหมือนเดิม

                // 1. วาดชั้นนอก (แสงฟุ้ง) - ให้วงใหญ่ขึ้น 2.5 เท่า และโปร่งใสมากๆ
                ctx.globalAlpha = this.isCore ? 0.2 : 0.1; 
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2.5, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                // 2. วาดชั้นใน (แกนกลาง) - สว่างคมชัด
                let coreAlpha = this.isCore ? (0.8 + Math.random() * 0.2) : 0.6;
                ctx.globalAlpha = coreAlpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1; 
            }
        }

        function initSystem() {
            particles.length = 0; 
            backgroundStars.length = 0;
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            baseScale = Math.min(w, h) / 50;

            for (let i = 0; i < 120; i++) backgroundStars.push(new Star());

            pPoints = getTextPoints('ม'); 

            for (let i = 0; i < pPoints.length; i++) particles.push(new Particle('text', i, true));
            for (let i = 0; i < 200; i++) particles.push(new Particle('text', Math.floor(Math.random() * pPoints.length), false));

            for (let i = 0; i < 1000; i++) particles.push(new Particle('heart', 0, true));
            for (let i = 0; i < 500; i++) particles.push(new Particle('heart', 0, false));
        }

        window.addEventListener('resize', initSystem);

        function animate() {
            ctx.globalCompositeOperation = 'source-over';
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            ctx.fillRect(0, 0, w, h);

            backgroundStars.forEach(star => {
                star.update();
                star.draw();
            });
            
            ctx.globalCompositeOperation = 'lighter';
            
            time += 0.01; 
            const beatValue = Math.sin(time * 4) * 2 + Math.sin(time * 6) * 0.5;

            particles.forEach(p => {
                p.update(beatValue);
                p.draw();
            });

            requestAnimationFrame(animate);
        }

        document.fonts.ready.then(() => {
            initSystem();
            setTimeout(animate, 200); 
        });
    </script>
</body>
</html>